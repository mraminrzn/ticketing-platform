# استراتژی بک‌اند برای سیستم چت و تیکتینگ

یک پلتفرم ارتباطی یکپارچه برای مدیریت پشتیبانی مشتریان از طریق تیکت‌های غیرهمزمان و چت زنده

## معماری سطح بالا

سیستم به چند سرویس اصلی (میکروسرویس) تقسیم می‌شود تا مقیاس‌پذیری و نگهداری آن ساده‌تر باشد:

- سرویس احراز هویت: مدیریت کاربران و نقش‌ها
- سرویس تیکتینگ: مدیریت کامل فرآیند تیکت‌ها
- سرویس چت: مدیریت ارتباطات زنده
- سرویس نوتیفیکیشن: ارسال اعلان‌های ایمیل و پوش
- API Gateway: نقطه ورود یکپارچه برای تمام درخواست‌ها

---

## ۱. احراز هویت و مدیریت نقش‌ها

### نقش‌ها (Roles)
- Customer: می‌تواند تیکت ایجاد کند، پیام ارسال کند و وارد چت شود.
- Operator: به تیکت‌ها و چت‌ها پاسخ می‌دهد و وضعیت آن‌ها را تغییر می‌دهد.
- Admin: به تمام سیستم دسترسی دارد و می‌تواند اپراتورها را مدیریت کند.

### فلو کاری احراز هویت
1. کاربر با نام کاربری و رمز عبور خود لاگین می‌کند.
2. سرور اطلاعات را تایید کرده و یک access_token و یک refresh_token از نوع JWT صادر می‌کند.
3. این توکن در هدر Authorization تمام درخواست‌های بعدی به API Gateway ارسال می‌شود.

---

## ۲. سیستم تیکتینگ (مبتنی بر صف)

### فلو کامل ایجاد و تخصیص تیکت
1. **ارسال درخواست**: کاربر یک درخواست POST به اندپوینت `/api/tickets` ارسال می‌کند.
2. **ایجاد تیکت اولیه**:
   - سرویس تیکتینگ درخواست را اعتبارسنجی می‌کند.
   - یک رکورد جدید در جدول Tickets با وضعیت `OPEN` ایجاد می‌کند.
   - اولین پیام کاربر را در جدول `Ticket_Replies` ذخیره می‌کند.
3. **تولید رویداد (Producer)**:
   - پس از ذخیره تیکت، سرویس یک پیام حاوی `ticket_id` و `department_id` به یک صف ارسال می‌کند.
4. **پردازش توسط ورکرها (Consumers)**:
   - یک یا چند Worker به صف گوش می‌دهند و پیام جدید را برای پردازش برمی‌دارند.
   - این Worker مسئول اجرای منطق تخصیص تیکت است.
5. **منطق تخصیص و توزیع بار**:
   - استراتژی **Least Busy**: تیکت به اپراتوری با کمترین تعداد تیکت فعال اختصاص می‌یابد.
   - استراتژی **Skill-Based**: تیکت‌ها بر اساس برچسب (مثلاً "فنی") به اپراتور با مهارت متناظر داده می‌شود.
6. **به‌روزرسانی و اطلاع‌رسانی**:
   - ورکر تیکت را با `operator_id` آپدیت کرده و وضعیت را به `PENDING_OPERATOR` تغییر می‌دهد.
   - یک رویداد دیگر برای اطلاع‌رسانی به اپراتور و کاربر ارسال می‌شود.

### مدیریت وضعیت تیکت
- **Open**: تازه ایجاد شده و در انتظار تخصیص.
- **Pending_Operator_Response**: منتظر پاسخ اپراتور.
- **Pending_Customer_Response**: منتظر پاسخ کاربر.
- **Closed**: مشکل حل شده و تیکت بسته شده است.
- **Reopened**: کاربر پس از بسته شدن، دوباره آن را باز کرده است.

---

## ۳. سیستم چت زنده (Real-time)

این بخش با استفاده از ارتباط پایدار و دوطرفه پیاده‌سازی می‌شود.

### فلو کامل چت زنده
1. **مدیریت وضعیت اپراتورها**:
   - وضعیت اپراتورها (`ONLINE`, `BUSY`, `OFFLINE`) در یک دیتابیس سریع مانند Redis مدیریت می‌شود.
2. **شروع چت توسط کاربر**:
   - کاربر روی دکمه "شروع چت" کلیک کرده و یک رویداد `start_chat` به همراه توکن JWT خود ارسال می‌کند.
3. **یافتن اپراتور و ایجاد اتاق (Room)**:
   - سرویس چت به دنبال یک اپراتور با وضعیت `ONLINE` می‌گردد.
   - اگر اپراتور آزاد بود: یک "اتاق چت" (Chat Room) منحصر به فرد ایجاد شده، کاربر و اپراتور به آن ملحق می‌شوند و وضعیت اپراتور به `BUSY` تغییر می‌کند.
   - اگر اپراتور آزاد نبود: کاربر در یک صف انتظار قرار گرفته و موقعیتش در صف به او اطلاع داده می‌شود.
4. **تبادل پیام**:
   - پیام‌ها از طریق رویداد `send_message` به سرور ارسال و برای عضو دیگر اتاق Broadcast می‌شوند.
   - تمام پیام‌ها برای سابقه در پایگاه داده ذخیره می‌شوند.
5. **پایان چت**:
   - با ارسال رویداد `end_chat`، سرور اتصال را قطع، چت را آرشیو و وضعیت اپراتور را به `ONLINE` برمی‌گرداند.

---

## فلوچارت سیستم تیکتینگ

1. ایجاد تیکت توسط کاربر  
2. ارسال درخواست `POST /api/tickets`  
3. دریافت توسط سرویس تیکتینگ  
4. اعتبارسنجی و پردازش اولیه  
5. ذخیره در پایگاه داده  
6. تیکت با وضعیت `OPEN` ثبت می‌شود  
7. ارسال رویداد به صف  
8. پردازش توسط Worker  
9. دریافت پیام از صف برای پردازش  
10. اجرای منطق توزیع بار  
11. انتخاب بهترین اپراتور (Least Busy)  
12. آپدیت تیکت  
13. تخصیص `operator_id` به تیکت  
14. ارسال نوتیفیکیشن به کاربر (ایمیل) و اپراتور  

---

## فلوچارت چت زنده

1. شروع چت توسط کاربر  
2. اتصال و ارسال رویداد  
3. جستجوی اپراتور آزاد  
4. استعلام وضعیت اپراتورها از Redis  
5. اگر اپراتور آزاد است → ایجاد اتاق چت  
6. اگر اپراتور آزاد نیست → ورود به صف انتظار  
7. تبادل پیام‌ها (ارتباط دوطرفه در اتاق چت)  
8. آرشیو کردن پیام‌ها (ذخیره مکالمات در پایگاه داده)  
9. پایان چت (بستن اتاق و آزاد کردن اپراتور)  
