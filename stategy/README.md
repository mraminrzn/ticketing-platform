# استراتژی بک‌اند برای سیستم گفتگوی یکپارچه

یک پلتفرم ارتباطی مدرن برای مدیریت پشتیبانی مشتریان بر پایه MongoDB

---

## معماری و تکنولوژی‌ها

سیستم بر پایه معماری میکروسرویس طراحی شده و از تکنولوژی‌های زیر استفاده می‌کند:

* **پایگاه داده اصلی (MongoDB):** برای ذخیره‌سازی تمام گفتگوها و پیام‌ها به صورت داکیومنت‌های BSON. این ساختار انعطاف‌پذیر و مقیاس‌پذیر است.
* **پایگاه داده حافظه موقت (Redis):** برای مدیریت وضعیت لحظه‌ای (آنلاین/آفلاین) اپراتورها، صف‌های انتظار و کش کردن اطلاعات ضروری.
* **ارتباط همزمان (WebSockets):** برای تبادل پیام‌های زنده بین کاربر و اپراتور.
* **صف پیام (Message Queue):** برای مدیریت و توزیع بار درخواست‌های جدید به صورت غیرهمزمان بین Worker ها.
* **سرویس‌ها:**
    * **سرویس احراز هویت:** مدیریت کاربران، نشست‌ها (Sessions) و توکن‌ها.
    * **سرویس گفتگو (Conversation):** هسته اصلی سیستم برای مدیریت ایجاد، تخصیص و تبادل پیام‌ها.
    * **سرویس نوتیفیکیشن:** ارسال اعلان‌های ایمیل و پوش.
    * **API Gateway:** نقطه ورود یکپارچه برای تمام درخواست‌ها.

---

## ۱. مدل داده یکپارچه در MongoDB

به جای جداول متعدد، از یک کالکشن داکیومنتی واحد استفاده می‌کنیم. این مدل برای سیستم گفتگو ایده‌آل است زیرا تمام اطلاعات یک مکالمه در یک مکان واحد ذخیره می‌شود.

* **کالکشن `chats`:** هر داکیومنت در این کالکشن نماینده یک گفتگوی کامل است.
* **پیام‌های تو در تو (Embedded Messages):** تمام پیام‌ها به صورت یک آرایه به نام `messages` در همان داکیومنت چت ذخیره می‌شوند.
* **مزیت کلیدی:** این مدل باعث می‌شود کل تاریخچه یک گفتگو با یک کوئری ساده و بدون نیاز به `JOIN` قابل بازیابی باشد که سرعت خواندن را به شدت افزایش می‌دهد.

### مدیریت وضعیت و نوع گفتگو

هر داکیومنت گفتگو دارای دو فیلد کلیدی برای مدیریت چرخه حیات خود است:

* **`status` (وضعیت):**
    * `OPEN`: گفتگو باز است و در حال رسیدگی توسط اپراتور می‌باشد.
    * `PENDING`: گفتگو در صف انتظار برای تخصیص به یک اپراتور است.
    * `CLOSED`: گفتگو حل شده و بسته شده است.
* **`type` (نوع):**
    * `CHAT`: گفتگو به صورت زنده (همزمان) در حال انجام است.
    * `TICKET`: گفتگو به یک تیکت (غیرهمزمان) تبدیل شده است.

---

## ۲. فلو کاری سیستم گفتگوی یکپارچه

این فلو به صورت پویا و هوشمند تصمیم می‌گیرد که یک درخواست جدید به یک چت زنده تبدیل شود یا یک تیکت.

1.  **شروع گفتگو:** کاربر اولین پیام خود را ارسال می‌کند.
2.  **ایجاد داکیومنت:** سرور یک **داکیومنت** جدید در کالکشن `chats` با وضعیت `PENDING` ایجاد کرده و پیام را در آرایه `messages` آن ذخیره می‌کند.
3.  **تولید رویداد (Producer):** شناسه داکیومنت چت (`chat_id`) به یک **صف پیام** ارسال می‌شود تا پردازش تخصیص در پس‌زمینه انجام شود.
4.  **پردازش توسط ورکر (Consumer):** یک ورکر پیام را از صف برمی‌دارد و با استفاده از اطلاعات لحظه‌ای در **Redis**، وضعیت آنلاین بودن اپراتورها را بررسی می‌کند.
5.  **منطق تخصیص (نقطه تصمیم‌گیری):**
    * **سناریوی الف: اپراتور آنلاین وجود دارد:**
        * ورکر گفتگو را به اپراتور در دسترس تخصیص می‌دهد.
        * داکیومنت چت را آپدیت می‌کند: `operator_id` اضافه شده، `status` به `OPEN` و `type` به `CHAT` تغییر می‌کند.
        * از طریق **WebSocket** به اپراتور اطلاع‌رسانی می‌شود تا به چت بپیوندد.
    * **سناریوی ب: هیچ اپراتوری آنلاین نیست:**
        * ورکر داکیومنت چت را آپدیت می‌کند: `type` به `TICKET` تغییر می‌کند.
        * وضعیت `PENDING` باقی می‌ماند تا گفتگو در اولین فرصت توسط یک اپراتور به عنوان تیکت رسیدگی شود.
6.  **پایان گفتگو:** پس از حل مشکل، اپراتور وضعیت گفتگو را به `CLOSED` تغییر می‌دهد و مکالمه در همان داکیومنت آرشیو می‌شود.

---

## فلوچارت پردازش پیام در سیستم

1.  **کاربر پیامی ارسال می‌کند**
    * اولین نقطه تماس؛ کاربر یک پیام جدید را آغاز می‌کند.
2.  **ایجاد داکیومنت چت در MongoDB**
    * یک داکیومنت جدید برای گفتگو با وضعیت `PENDING` ایجاد می‌شود.
3.  **ارسال رویداد به صف پیام**
    * شناسه گفتگو (`chat_id`) برای پردازش غیرهمزمان ارسال می‌شود.
4.  **ورکر رویداد را پردازش می‌کند**
    * یک ورکر آزاد، پیام را از صف برداشته و منطق تخصیص را آغاز می‌کند.
5.  **بررسی وضعیت اپراتورها در Redis**
    * ورکر از Redis استعلام می‌گیرد: آیا اپراتور آنلاینی در دسترس است؟
6.  **تصمیم‌گیری بر اساس نتیجه:**
    * **مسیر الف: اگر اپراتور آنلاین بود**
        * **تخصیص گفتگو و شروع چت زنده:** گفتگو به اپراتور تخصیص یافته، نوع به `CHAT` تغییر کرده و اطلاع‌رسانی می‌شود.
    * **مسیر ب: اگر اپراتور آنلاین نبود**
        * **گفتگو به تیکت تبدیل می‌شود:** نوع گفتگو به `TICKET` تغییر کرده و در صف انتظار باقی می‌ماند.
7.  **پایان گفتگو**
    * پس از حل مشکل، وضعیت گفتگو به `CLOSED` تغییر کرده و در دیتابیس ذخیره می‌شود.